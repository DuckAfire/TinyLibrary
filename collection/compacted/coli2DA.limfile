-- NAME:    coli2DA
-- AUTHOR:  DuckAfire
-- VERSION: 4.0.3
-- LICENSE: Zlib License
--
-- Copyright (C) 2024 DuckAfire <duckafire.github.io/nest>
--
-- This software is provided 'as-is', without any express or implied
-- warranty. In no event will the authors be held liable for any damages
-- arising from the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictions:
--
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software. If you use this software
--    in a product, an acknowledgment in the product documentation would be
--    appreciated but is not required.
-- 2. Altered source versions must be plainly marked as such, and must not be
--    misrepresented as being the original software.
-- 3. This notice may not be removed or altered from any source distribution.

local TL1={}
do local T63,E3,TU6,MS22,F33,M42,T21,MM12,MM14,M43,MA0=trace,error,table.unpack,math.sqrt,fget,mget,type,math.max,math.min,mouse,math.abs local function libError(a,b,c,d,e,f)if a~=nil then if not a then return end end local g={"Error","Function","Index"}local h={nil,e,"#"..f}local i="\n\n[LIB]"b=b and'"'..b..'" ' or"" local function j(k)h[1]=b..k end if c=="1" then j("was not specified")elseif c=="2" then j("was not defined")elseif c=="3" then j("is invalid")else j(c)end for l=1,3 do i=i.."\n"..g[l]..": "..h[l].."." if l==1 and d~=nil then i=i.."\nTry: " for m=1,#d-1 do i=i..d[l].." | " end i=i..d[#d]end end T63("\n>\n>\n>")E3(i.."\n")end local RE="rect" local CI="circ" local SI="simp" local W="width" local H="height" local R="radius" local ByBd=1 local OrgBd={"newBody","distance","mapAlign","tile","tileCross","rectangle","circle","shapesMix","impactPixel"} TL1newBody=function(a,b,c,d,e)local f=nil if a==RE then f={x=b,y=c,width=d or 8,height=e or 8}elseif a==CI then f={x=b,y=c,radius=d or 4}elseif a==SI then f={x=b,y=c}end libError(f==nil,"type","3",{RE,CI,SI},OrgBd[ByBd],1)local g={"x","y"}for h=1,2 do libError(f[g[h]]==nil,g[h],"3",nil,OrgBd[ByBd],1+h)end return f end local function ckbd(a,b,c) ByBd=c local d,e,f d={}e={"x","y","width","height"}f={[RE]=4,[CI]=3,[SI]=2}for g=1,#a do d[g]={}for h=1,f[b[g]]do if b[g]==CI and h==3 and a[g][R]~=nil then d[g][h]=a[g][R]else d[g][h]=a[g][e[h]]or a[g][h]end end end local i={}for g=1,#a do i[g]=TL1newBody(b[g],d[g].x or d[g][1],d[g].y or d[g][2],d[g][W]or d[g][R]or d[g][3],d[g][H]or d[g][4])end ByBd=1 return TU6(i) end TL1distance=function(a,b)a,b=ckbd({a,b},{SI,SI},2)return MS22((a.x-b.x)^2+(a.y-b.y)^2) end TL1mapAlign=function(a,b)a=ckbd({a},{(b)and RE or SI},3)if b then a[W]=a[W]or 8 a[H]=a[H]or 8 a.x=a.x+a[W]//2 a.y=a.y+a[H]//2 end return(a.x//8)*8,(a.y//8)*8 end TL1tile=function(a,b,c,d,e)a=ckbd({a},{RE},4)d=d or 0 e=e or 0 local f,g,h,i local j,k=a[W],a[H]if b=="top" then f,g,h,i=0,-1,j-1,-1 elseif b=="bottom" then f,g,h,i=0,k,j-1,k elseif b=="left" then f,g,h,i=-1,0,-1,k-1 elseif b=="right" then f,g,h,i=j,0,j,k-1 else libError(nil,"type","3",{"top","bottom","left","right"},"tile","(last)")end return F33(M42((a.x+f)//8+d,(a.y+g)//8+e),c)and F33(M42((a.x+h)//8+d,(a.y+i)//8+e),c)end TL1tileCross=function(a,b,c,d,e)a=ckbd({a},{RE},5)local f={}for g=1,4 do f[g]=(T21(c)=="number")and c or(T21(c)~="table")and 0 or c[g]end local h={}local i={"top","bottom","left","right"}for g=1,4 do h[g-1]=TL1tile(a,i[g],f[g],d,e)end return(b)and{top=h[0],bottom=h[1],left=h[2],right=h[3]}or h end TL1box360=function(a,b,c,d,e,f)local g=TL1tileCross(c,false,d,e,f)local h=b and((b<0 and g[0])or(b>0 and g[1]))or false local i=a and((a<0 and g[2])or(a>0 and g[3]))or false return h or i end TL1rectangle=function(a,b)local c,d={a,b},{W,H}for e=1,2 do for f=3,4 do if not c[e][f]and not c[e][d[f]]then c[e][f]=1 end end end c[1],c[2]=ckbd({c[1],c[2]},{RE,RE},6)return MM12(c[1].x,c[2].x)<MM14(c[1].x+c[1][W],c[2].x+c[2][W])and MM12(c[1].y,c[2].y)<MM14(c[1].y+c[1][H],c[2].y+c[2][H])end TL1circle=function(a,b)local c={a,b}for d=1,2 do if not c[d][3]and not c[d][R]then c[d][3]=0 end end c[1],c[2]=ckbd({c[1],c[2]},{CI,CI},7)return(c[1].x-c[2].x)^2+(c[1].y-c[2].y)^2<=(c[1][R]+c[2][R])^2 end TL1shapesMix=function(a,b)a,b=ckbd({a,b},{CI,RE},8)if TL1rectangle({a.x,a.y},b)or TL1circle({b.x+b[W]//2,b.y+b[H]//2},a)then return true end local c=a[R]*MS22(2)if TL1rectangle(b,{1+a.x-c/2,1+a.y-c/2,c,c})then return true end local d=1 local e={TL1distance({a.x,a.y},{b.x,b.y}), TL1distance({a.x,a.y},{b.x+b[W],b.y}), TL1distance({a.x,a.y},{b.x,b.y+b[H]}), TL1distance({a.x,a.y},{b.x+b[W],b.y+b[H]}), }local f={e[1],e[2]} local g={{3,4},{1,3},{2,4}} for h=1,3 do if e[g[h][1]]<f[1]or e[g[h][2]]<f[2]then d=h+1 f[1]=e[g[h][1]]f[2]=e[g[h][2]]end end local i={{{b.x,b.y},{b.x+b[W],b.y}}, {{b.x,b.y+b[H]},{b.x+b[W],b.y+b[H]}}, {{b.x,b.y},{b.x,b.y+b[H]}}, {{b.x+b[W],b.y},{b.x+b[W],b.y+b[H]}}, }local j,k=i[d][1],i[d][2]while true do if TL1circle({j[1],j[2]},a)then return true end if j[1]==k[1]and j[2]==k[2]then return false end j[1]=(j[1]+1<k[1])and j[1]+1 or k[1] j[2]=(j[2]+1<k[2])and j[2]+1 or k[2] end end TL1touch=function(a,b,c,d,e)local f={}f.x,f.y=M43()e=e or{}f[W]=MA0(e[W]or e[1]or 1)f[H]=MA0(e[H]or e[2]or 1)return f.x+f[W]-1>=a and f.x<=c and f.y+f[H]-1>=b and f.y<=d end TL1impactPixel=function(a,b,c,d)libError(a~=RE and a~=CI,"type","3",{RE,CI},OrgBd[9],"(first)")b,c=ckbd({b,c},{a,a},9)if a==RE then if not d and not TL1rectangle(b,c)then return nil,nil end local e={x=b.x+b[W]/2,y=b.y+b[H]/2,[R]=(b[W]+b[H])/2}local f={x=c.x+c[W]/2,y=c.y+c[H]/2,[R]=(c[W]+c[H])/2}return TL1impactPixel(CI,e,f,true)end if a==CI then if not d and not TL1circle(b,c)then return nil,nil end local g=(b.x*c[R])+(c.x*b[R])local h=(b.y*c[R])+(c.y*b[R])local i=(b[R]+c[R])return g/i,h/i end end end
--local reference=TL1
