-- [COMPACTED] Copy and paste the code in your cart [v: 1.6]

local DAMIT,DA="github.com/DuckAfire/TinyLibrary/blob/main/LICENSE",{}

do local function E(p,f) error('The parameter "Type" is invalid, try "'..p..'" (function: "coli2DA.'..f..'")') end DA.newBody=function(t,x,y,wr,h) local b={x=x,y=y} if t=="rect" then b.width.height=wr,h elseif t=="circ" then b.radius=wr elseif t ~= "simp" then E('rect" or "circ','newBody')  end return b end local function C(p,t) local I,b,l=1,{{},{}},0 for i=1,#t do local a,c,r=t[i]=="circ" and 1 or t[i]=="simp" and 2 or 0,p[I],0 if type(c)=="table" then if c.x then b[i]=c else b[i]=newBody(t[i],c[1],c[2],c[3],c[4]) end l=l+1 else r,b[i]=3,newBody(t[i],p[I],p[I+1],p[I+2],p[I+3]) l=l+4-a end if r==3 then I=5-a else I=2 end end return b[1],b[2],p,l+1 end DA.distance=function(...) local a,b=C({...},{"simp","simp"}) return math.sqrt((a.x-b.x)^2+(a.y-b.y)^2) end DA.mapAlign=function(...) local p={...} if type(p[1])~="table" and #p<4 then error('[coli2DA] Parameters not expecified in table "mapAlign".') end local o,_,P,l=C(p,{"rect"}) if P[l] then local w,h=o.width or 8,o.height or 8 o.x,o.y=o.x+w//2,o.y+h//2 end return (o.x//8)*8,(o.y//8)*8 end DA.tile=function(...) local o,_,p,l=C({...},{"rect"}) local w,h,f,P,a,b,c,d=o.width,o.height,p[l+1] or 0,p[l] if P=="top" then a,b,c,d=0,-1,w-1,-1 elseif P=="below" then a,b,c,d=0,h,w-1, h elseif P=="left" then a,b,c,d=-1,0,-1,h-1 elseif P=="right" then a,b,c,d=w,0,w,h-1 else E('top", "below", "left" or "right','tile') end return fget(mget((o.x+a)//8,(o.y+b)//8),f) and fget(mget((o.x+c)//8,(o.y+d)//8),f) end DA.tileCross=function(...) local t=DA.tile local o,_,p,l=C({...},{"rect"}) return p[l] and {top=t(o,"top"),below=t(o,"below"),left=t(o,"left"),right=t(o,"right")} or {t(o,"top"),t(o,"below"),t(o,"left"),t(o,"right")} end DA.touch=function(...) local o,c=C({...},{"rect","rect"}) c.width,c.height,c.x,c.y=c.width and math.abs(c.width) or 0,c.height and math.abs(c.height) or 0,mouse() return c.x+c.width-1>=o.x and c.x<=o.x+o.width-o.x and c.y+c.height-1>=o.y and c.y<=o.y+o.height-o.y end DA.impactPixel=function(...) local p,a,b={...} if p[#p-1]== "rect" then a,b="rect","rect" elseif p[#p-1]== "circ" then a,b="circ","circ" elseif p[#p-1]== "mix" then a,b="circ","rect" else E('rect", "circ" or "mix','impactPixel') end local A,B,P,l=C(p,{a,b}) if P[l]=="rect" then local _A,_B={x=A.x+A.width/2,y=A.y+A.height/2,radius=(A.width+A.height)/2},{x=B.x+B.width/2,y=B.y+B.height/2,radius=(B.width+B.height)/2} return DA.impactPixel(_A,_B,"circ") elseif P[l]=="circ" then local x,y,tr=(A.x*B.radius)+(B.x*A.radius),(A.y*B.radius)+(B.y*A.radius),(A.radius+B.radius) return x/tr,y/tr elseif P[l]=="mix" then local c,r,x,y={x=A.x,y=A.y,radius=A.radius},{t=B.x,b=B.y+B.height-1,l=B.y,r=B.y+B.width-1} if c.x<=r.l then x=r.l elseif c.x>r.r then x=r.r else x=c.x end if c.y<=r.t then y=r.t elseif c.y>r.b then y=r.b else y=c.y end return x,y end end DA.rectangle=function(...) local a,b=C({... },{"rect","rect"}) local aw,ah,bw,bh=a.width or 1,a.height or 1,b.width or 1,b.height or 1 aw,ah,bw,bh=math.abs(aw)-1,math.abs(ah)-1,math.abs(bw)-1,math.abs(bh)-1 return a.x+aw>=b.x and a.x<=b.x+bw and a.y+ah>=b.y and a.y<=b.y+bh end DA.circle=function(...) local a,b,p,l=C({...},{"circ","circ"}) local tr=p[l] and a.radius+b.radius or b.radius return (a.x-b.x)^2+(a.y-b.y)^2<=tr^2 end local function shapesMix(...) local c,r=C({...},{"circ","rect"}) local t={radius=0} t.x,t.y=DA.impactPixel(c,r,"mix") return DA.circle(t,c) end end

local coli=DA

-- NOTE: in functions ".shapeMix" and ".impactPixel"(in mode "mix"), only the "circle" can move, because moving the "square/rectangle" will generate unexpected results.