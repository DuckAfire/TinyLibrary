local DA1={}
do local E3,T21,MS22,F33,M42,MM12,MM14,M43,MA0=error,type,math.sqrt,fget,mget,math.max,math.min,mouse,math.abs local function libError(a,b,c,d)local e=a if b~=nil then e="\nInvalid argument: "..a.."\nTry: " for f=1,#b do e=e..b[f].." | " end end E3("\n\n[coli2DA]"..e.."\nFunction: "..c.."\nParameter: #"..d.."\n")end local RE="rect" local CI="circ" local SI="simp" DA1.newBody=function(a,b,c,d,e)trace(a)if a==RE then return{x=b,y=c,width=d or 8,height=e or 8}end if a==CI then return{x=b,y=c,radius=d or 4}end if a==SI then return{x=b,y=c}end libError("type",{RE,CI,SI},"newBody",1)end local function ckbd(a,b)local c,d,e,f,g,h=1,{{},{}},0,nil,nil for i=1,#b do f,g,h=a[c],true,(b[i]==CI and 1 or b[i]==SI and 2 or 0)if T21(f)=="table" then d[i]=DA1.newBody(b[i],f.x or f[1],f.y or f[2],f.width or f.radius or f[3],f.height or f[4])e=e+1 else g=false e=e+4-h d[i]=DA1.newBody(b[i],a[c],a[c+1],a[c+2],a[c+3])end if g then c=2 else c=5-h end end return d[1],d[2],a,e+1 end DA1.distance=function(...)local a,b=ckbd({...},{SI,SI})return MS22((a.x-b.x)^2+(a.y-b.y)^2)end DA1.mapAlign=function(...)local a={...}local b,c,d,e,f=(T21(a[1])=="table" or(T21(a[1])~="table" and#a>=4))and RE or SI if T21(a[1])~="table" and#a<2 then libError("Insuficient arguments for this call format",nil,"mapAlign","(quantity)")end c,g,a,d=ckbd(a,{b})e,f=c.x,c.y if a[d]then c.width=c.width or 8 c.height=c.height or 8 e=e+c.width//2 f=f+c.height//2 end return(e//8)*8,(f//8)*8 end DA1.tile=function(...)local a,b,c,d=ckbd({...},{RE})local e,f,g=a.width,a.height local h,i,j,k local g=c[d+1]or 0 local l=c[d+2]or 0 local m=c[d+3]or 0 if c[d]=="top" then h,i,j,k=0,-1,e-1,-1 elseif c[d]=="below" then h,i,j,k=0,f,e-1,f elseif c[d]=="left" then h,i,j,k=-1,0,-1,f-1 elseif c[d]=="right" then h,i,j,k=e,0,e,f-1 else libError("type",{"top","below","left","right"},"tile","(last)")end return F33(M42((a.x+h)//8+l,(a.y+i)//8+m),g)and F33(M42((a.x+j)//8+l,(a.y+k)//8+m),g)end DA1.tileCross=function(...)local a,b,c,d=ckbd({...},{RE})local e=T21(c[d+1])=="table" and c[d+1]or{}for f=1,4 do if not e[f]or T21(e[f])~="number" then e[f]=T21(c[d+1])=="number" and c[d+1]or 0 end end local g={}local h={[0]="top","below","left","right"}for f=0,3 do g[f]=DA1.tile(a,h[f],e[f+1],c[d+2],c[d+3])end return c[d]and{top=g[0],below=g[1],left=g[2],right=g[3]}or g end DA1.box360=function(a,b,c,d)local e=DA1.tileCross(c,false,d)local f=b and((b<0 and e[0])or(b>0 and e[1]))or false local g=a and((a<0 and e[2])or(a>0 and e[3]))or false return f or g end DA1.rectangle=function(...)local a={...}local b=T21(a[#a])=="boolean" and a[#a]or false local c=b and SI or RE local d,e=ckbd(a,{c,RE})if b then d.width,d.height=1,1 end return MM12(d.x,e.x)<MM14(d.x+d.width,e.x+e.width)and MM12(d.y,e.y)<MM14(d.y+d.height,e.y+e.height)end DA1.circle=function(...)local a={...}local b=T21(a[#a])=="boolean" and a[#a]or false local c=b and SI or CI local d,e=ckbd(a,{c,CI})local f=b and e.radius or d.radius+e.radius return(d.x-e.x)^2+(d.y-e.y)^2<=f^2 end DA1.shapesMix=function(...)local a,b=ckbd({...},{CI,RE})if DA1.rectangle({a.x,a.y},b,true)or DA1.circle({b.x+b.width//2,b.y+b.height//2},a,true)then return true end local c=a.radius*MS22(2)if DA1.rectangle(b,{1+a.x-c/2,1+a.y-c/2,c,c})then return true end local d,e=1,{DA1.distance({a.x,a.y},{b.x,b.y}),DA1.distance({a.x,a.y},{b.x+b.width,b.y}),DA1.distance({a.x,a.y},{b.x,b.y+b.height}),DA1.distance({a.x,a.y},{b.x+b.width,b.y+b.height}),}local f,g={e[1],e[2]},{{3,4},{1,3},{2,4}}for h=1,3 do if e[g[h][1]]<f[1]or e[g[h][2]]<f[2]then d=h+1 f[1]=e[g[h][1]]f[2]=e[g[h][2]]end end local i={{{b.x,b.y},{b.x+b.width,b.y}},{{b.x,b.y+b.height},{b.x+b.width,b.y+b.height}},{{b.x,b.y},{b.x,b.y+b.height}},{{b.x+b.width,b.y},{b.x+b.width,b.y+b.height}},}local j,k=i[d][1],i[d][2]while true do if DA1.circle({j[1],j[2]},a,true)then return true end if j[1]==k[1]and j[2]==k[2]then return false end j[1]=(j[1]+1<k[1])and j[1]+1 or k[1]j[2]=(j[2]+1<k[2])and j[2]+1 or k[2]end end DA1.touch=function(a,b,c,d,e)local f={}f.x,f.y=M43()e=e or{}f.width=e.width and MA0(e.width)or e[1]and MA0(e[1])or 1 f.height=e.height and MA0(e.height)or e[2]and MA0(e[2])or 1 return DA1.rectangle(f,{a,b,c,d})end DA1.impactPixel=function(...)local a={...}local b=T21(a[#a])=="boolean" and#a-1 or#a if a[b]~=RE and a[b]~=CI then libError("type",{RE,CI},"impactPixel","(first)")end local c,d,e,f=ckbd(a,{a[b],a[b]})if e[b]==RE then if not e[b+1]and not DA1.rectangle(c,d)then return nil,nil end local g={x=c.x+c.width/2,y=c.y+c.height/2,radius=(c.width+c.height)/2}local h={x=d.x+d.width/2,y=d.y+d.height/2,radius=(d.width+d.height)/2}return DA1.impactPixel(g,h,CI,true)elseif e[i]==CI then if not e[b+1]and not DA1.circle(c,d)then return nil,nil end local j=(c.x*d.radius)+(d.x*c.radius)local k=(c.y*d.radius)+(d.y*c.radius)local l=(c.radius+d.radius)return j/l,k/l end end end
--local reference=DA1
