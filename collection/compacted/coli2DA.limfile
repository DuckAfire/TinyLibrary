-- NAME:    coli2DA
-- AUTHOR:  DuckAfire
-- VERSION: 4.0.0
-- LICENSE: Zlib License
--
-- Copyright (C) 2024 DuckAfire <duckafire.github.io/nest>
--
-- This software is provided 'as-is', without any express or implied
-- warranty. In no event will the authors be held liable for any damages
-- arising from the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictions:
--
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software. If you use this software
--    in a product, an acknowledgment in the product documentation would be
--    appreciated but is not required.
-- 2. Altered source versions must be plainly marked as such, and must not be
--    misrepresented as being the original software.
-- 3. This notice may not be removed or altered from any source distribution.

local DA1={}
do local T63,E3,TU6,MS22,F33,M42,T21,MM12,MM14,M43,MA0=trace,error,table.unpack,math.sqrt,fget,mget,type,math.max,math.min,mouse,math.abs local function libError(a,b,c,d,e,f)if a~=nil then if not a then return end end local g={"Error","Function","Index"}local h={nil,e,"#"..f}local i="\n\n[coli2DA]"b=b and'"'..b..'"' or"" local function j(k)h[1]=b..k end if c=="1" then j("was not specified")elseif c=="2" then j("was not defined")elseif c=="3" then j("is invalid")else j(c)end for l=1,3 do i=i.."\n"..g[l]..": "..h[l].."." if l==1 and d~=nil then i=i.."\nTry: " for m=1,#d-1 do i=i.." | " end n=i..d[#d] end end T63("\n>\n>\n>")E3(i.."\n")end local RE, o,p,q,r,s="rect","circ","simp","width","height","radius" local ByBd, t=1,{"newBody","distance","mapAlign","tile","tileCross","rectangle","circle","shapesMix","impactPixel"} DA1.newBody=function(a,b,c,d,e)local f=nil if a==g then f={x=b,y=c,width=d or 8,height=e or 8}end if a==h then f={x=b,y=c,radius=d or 4}end if a==i then f={x=b,y=c}end libError(f==nil,"type","3",{g,h,i},j[k],1)local l={"x","y"}for m=1,2 do libError(f[l[m]]==nil,l[m],"3",nil,j[k],1+m)end return f end local function ckbd(a,b,c) d=c local e={}for f=1,#a do for g=1,#a[f]do e[f][g]=a[f][g]end end local h={}for f=1,#e do h[f]=DA1.newBody(b[f],e[f].x or e[f][1],e[f].y or e[f][2],e[f][i]or e[f][j]or e[f][3],e[f][k]or e[f][4])end d=1 return TU6(h)end DA1.distance=function(a,b)a,b=ckbd({a,b},{c,c},2)return MS22((a.x-b.x)^2+(a.y-b.y)^2)end DA1.mapAlign=function(a,b)a=ckbd({a},{(b)and c or d},3)if b then a[e]=a[e]or 8 a[f]=a[f]or 8 a.x=a.x+a[e]//2 a.y=a.y+a[f]//2 end return(a.x//8)*8,(a.y//8)*8 end DA1.tile=function(a,b,c,d,e)a=ckbd({a},{f},4)local g,h,i,j local k,l=a[m],a[n]if b=="top" then g,h,i,j=0,-1,k-1,-1 elseif b=="below" then g,h,i,j=0,l,k-1,l elseif b=="left" then g,h,i,j=-1,0,-1,l-1 elseif b=="right" then g,h,i,j=k,0,k,l-1 else libError(nil,"type","3",{"top","below","left","right"},"tile","(last)")end return F33(M42((a.x+g)//8+d,(a.y+h)//8+e),c)and F33(M42((a.x+i)//8+d,(a.y+j)//8+e),c)end DA1.tileCross=function(a,b,c,d,e)a=ckbd({a},{f},5)local g={}for h=1,4 do g[h]=(T21(c)=="number")and c or(T21(c)~="table")and 0 or c[h]end local i={}local j={"top","below","left","right"}for h=0,3 do i[h]=DA1.tile(a,j[h+1],g[h+1],d,e)end return(b)and{top=i[0],below=i[1],left=i[2],right=i[3]}or i end DA1.box360=function(a,b,c,d,e,f)local g=DA1.tileCross(c,false,d,e,f)local h=b and((b<0 and g[0])or(b>0 and g[1]))or false local i=a and((a<0 and g[2])or(a>0 and g[3]))or false return h or i end DA1.rectangle=function(a,b,c)a,b=ckbd({a,b},{(c)and d or e,e},6)if c then f[g],f[h]=1,1 end return MM12(f.x,i.x)<MM14(f.x+f[g],i.x+i[g])and MM12(f.y,i.y)<MM14(f.y+f[h],i.y+i[h])end DA1.circle=function(a,b,c)a,b=ckbd({a,b},{(c)and d or e,e},7)local f=(c)and b[g]or a[g]+b[g]return(a.x-b.x)^2+(a.y-b.y)^2<=f^2 end DA1.shapesMix=function(a,b)a,b=ckbd({a,b},{c,d},8)if DA1.rectangle({a.x,a.y},b,true)or DA1.circle({b.x+b[e]//2,b.y+b[f]//2},a,true)then return true end local g=a[h]*MS22(2)if DA1.rectangle(b,{1+a.x-g/2,1+a.y-g/2,g,g})then return true end local i,j=1,{DA1.distance({a.x,a.y},{b.x,b.y}), DA1.distance({a.x,a.y},{b.x+b[e],b.y}), DA1.distance({a.x,a.y},{b.x,b.y+b[f]}), DA1.distance({a.x,a.y},{b.x+b[e],b.y+b[f]}), }local k,l={j[1],j[2]},{{3,4},{1,3},{2,4}}for m=1,3 do if j[l[m][1]]<k[1]or j[l[m][2]]<k[2]then i=m+1 k[1]=j[l[m][1]]k[2]=j[l[m][2]]end end local n={{{b.x,b.y},{b.x+b[e],b.y}}, {{b.x,b.y+b[f]},{b.x+b[e],b.y+b[f]}}, {{b.x,b.y},{b.x,b.y+b[f]}}, {{b.x+b[e],b.y},{b.x+b[e],b.y+b[f]}}, }local o,p=n[i][1],n[i][2]while true do if DA1.circle({o[1],o[2]},a,true)then return true end if o[1]==p[1]and o[2]==p[2]then return false end o[1]=(o[1]+1<p[1])and o[1]+1 or p[1] o[2]=(o[2]+1<p[2])and o[2]+1 or p[2] end end DA1.touch=function(a,b,c,d,e)local f={}f.x,f.y=M43()e=e or{}f[g]=MA0(e[g]or e[1]or 1)f[h]=MA0(e[h]or e[2]or 1)return f.x+f[g]-1>=a and f.x<=c and f.y+f[h]-1>=b and f.y<=d end DA1.impactPixel=function(a,b,c,d)if c~=e and c~=f then libError(nil,"type","3",{e,f},"impactPixel","(first)")end a,g=ckbd({a,g},{c,c},9)if c==e then if not h[i+1]and not DA1.rectangle(a,g)then return nil,nil end local j={x=a.x+a[k]/2,y=a.y+a[l]/2,radius=(a[k]+a[l])/2}local m={x=g.x+g[k]/2,y=g.y+g[l]/2,radius=(g[k]+g[l])/2}return DA1.impactPixel(j,m,f,true)end if c==f then if not d and not DA1.circle(a,g)then return nil,nil end local n=(a.x*g[o])+(g.x*a[o])local p=(a.y*g[o])+(g.y*a[o])local q=(a[o]+g[o])return n/q,p/q end end end
--local reference=DA1
