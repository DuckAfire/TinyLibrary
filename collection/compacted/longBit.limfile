-- NAME:    longBit
-- AUTHOR:  DuckAfire
-- VERSION: 3.5.1
-- LICENSE: Zlib License
--
-- Copyright (C) 2024 DuckAfire <duckafire.github.io/nest>
--
-- This software is provided 'as-is', without any express or implied
-- warranty. In no event will the authors be held liable for any damages
-- arising from the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictions:
--
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software. If you use this software
--    in a product, an acknowledgment in the product documentation would be
--    appreciated but is not required.
-- 2. Altered source versions must be plainly marked as such, and must not be
--    misrepresented as being the original software.
-- 3. This notice may not be removed or altered from any source distribution.

local TL4={}
do local T63,E3,P51,T19,SS14,T20,T21,SF3,TI1=trace,error,pmem,tonumber,string.sub,tostring,type,string.find,table.insert local function libError(a,b,c,d,e,f)if a~=nil then if not a then return end end local g={"Error","Function","Index"}local h={nil,e,"#"..f}local i="\n\n[LIB]"b=b and'"'..b..'" ' or"" local function j(k)h[1]=b..k end if c=="1" then j("was not specified")elseif c=="2" then j("was not defined")elseif c=="3" then j("is invalid")else j(c)end for l=1,3 do i=i.."\n"..g[l]..": "..h[l].."." if l==1 and d~=nil then i=i.."\nTry: " for m=1,#d-1 do i=i..d[l].." | " end i=i..d[#d]end end T63("\n>\n>\n>")E3(i.."\n")end local ZERO=2000000000 local MAX=2999999999 local LBC={} local CID={} local Origin={"getNum","getBool","setNum","setAll","update"}local GetBy=1 local SetBy=3 local AllBy=4 local function classToId(a,b,c)for d=1,#CID do if a==LBC[CID[d]]then return CID[d]end end libError(nil,nil,"Invalid class ("..a..")",nil,b,c)end local function ckSign(a,b,c)libError(a<0,nil,"It is not possible store negative values",nil,b,c)end local function ckId(a,b,c,d)a=(d~=2)and a or classToId(a,b,c)libError(a<0 or a>((d==1)and 255 or 9),"Index","3",nil,b,c)end local function ckDf(a,b,c)libError(P51(a)<ZERO or P51(a)>MAX,nil,"Memory not defined or invalid",nil,b,c)end local function ckGet(a,b,c,d)b=b or 1 libError(b<=0,"length","3",nil,c,d+2)local e={a+1,a+1+b-1}for f=1,2 do libError(e[f]<2-1*(f-1)or e[f]>10,((f==1)and"index" or"length"),"3",nil,c,d+2*(f-1))end return e[1],e[2] end TL4.getNum=function(a,b,c)ckId(a,Origin[GetBy],1,0)local d=classToId(b,"getNum",2)a,c=ckGet(a,c,Origin[GetBy],1)GetBy=1 return T19(SS14(T20(P51(d)),a,c))end TL4.getBool=function(a,b,c,d)GetBy=2 return TL4.getNum(a,b,d)==(c or 1)end TL4.getClass=function(a)ckId(a,"getClass",1,1)return LBC[a]end TL4.getAll=function(a,b)local c=classToId(a,"getAll",1)ckDf(c,"getAll",1)local d=SS14(T20(P51(c)),2)if b then return d end return T20(T19(d)) end TL4.setClass=function(a,b,c)c=c or 0 libError(T21(a)~="table","classes","1",nil,"setClass",1)local d=c+#a-1 libError(d>255,nil,"Index overflow (init + #classes - 1 > 255)",nil,"setClass",1)local e=1 local f=1 local g=false local h=false for i=c,d do libError(a[e]=="" or SF3(a[e]," ")~=nil,nil,"Invalid class. Do not use void strings or strings with spaces",nil,"setClass",1)h=(LBC[i]~=nil)if not h or b then LBC[i]=a[e] f=f+1 end e=e+1 g=true if not h then for j=1,#CID do if CID[j]==i then g=false break end end end if g then TI1(CID,i)end end return(#a==f)end TL4.setNum=function(a,b,c,d)local e,f="",0 b,d=ckGet(b,d,Origin[SetBy],2)if T21(a)=="boolean" then g=(a)and 1 or 0 else g=T20(a)local h=(d+1)-b if h>1 then for i=1,h do if#g<h then g="0"..g else break end end end f=T19(g) libError(f>10^h,nil,"Sub-memory OVERFLOW",nil,Origin[SetBy],1)end ckSign(f,Origin[SetBy],1)local j=classToId(c,Origin[SetBy],3)local function k(l,m)return SS14(T20(P51(j)),l,m)end local n=k(1,b-1)local o=k(d+1)SetBy=3 P51(j,T19(n..g..o))end TL4.setAll=function(a,b,c,d)if not c then ckSign(a,Origin[AllBy],1)end local e=classToId(b,Origin[AllBy],2)if c then a=P51(e)+a else a=T20(a) if#a<9 then for f=1,9-#a do a="0"..a end end a=T19("2"..a)end local g=(a<ZERO)and-1 or(a>MAX)and 1 or 0 if h then if g<0 then P51(e,ZERO) elseif g>0 then P51(e,MAX) else P51(e,a) end else libError(g<0,nil,"[ UNDERFLOW ]",nil,"setAll",1)libError(g>0,nil,"[ OVERFLOW ]",nil,"setAll",1)P51(e,a)end AllBy=4 return g end TL4.boot=function(a,b,c,d,e)c=c or 0 e=(T19(e)~=nil)and e or 0 local f,g,h=0,"",0 ckId(c,"boot",3,1)ckId(e,"boot",5,0) local i=c+#a-1 libError(#a>256,nil,"The table specified is bigger that 256",nil,"boot",1)libError(i>255,nil,"Index overflow (init + #items - 1 > 255)",nil,"boot",1)for j=c,i do f=f+1 if P51(j)<=ZERO or b then g=a[f]h=T19(g)ckSign(h,"boot",1)libError(T21(g)~="string",nil,g.." is not a string",nil,"boot",1)libError(T19(h)==nil,nil,g.." cannot be converted to number",nil,"boot",1)libError(T19(h)>MAX,nil,g.." is too large (max: "..MAX..")",nil,"boot",1)while#g<9 do g=(d)and e..g or g..e end P51(j,T19("2"..g))end end return(#a==f)end TL4.update=function(a,b,c)ckDf(classToId(a,"update",2),"update",2)local d={#b,#c,'"values"','"indexes"'}for e=1,2 do libError(d[e]<1 or d[e]>9,d[e+2],"invalid quantity of indexes",{"(min: 1","max: 9)"},"update",1+e)end libError(#b~=#c,nil,"The quantity of values and indexes must be equal",nil,"update","2-3")GetBy,SetBy=5,5 local f,g,h="",0,0 for e=1,#c do f="values["..e.."] is not a "g=T19(b[e])libError(T21(b[e])~="string",nil,f.."string",nil,"update",1)libError(g==nil,nil,f.."number",nil,"update",1)if TL4.getNum(c[e],a,#b[e])~=g then TL4.setNum(g,c[e],a,#b[e])h=h+1 end end return h end TL4.clear=function(a,b,c,d)local e=false local f={"all","memory","class","nonMemory","nonClass"}for g=1,#f do if a==f[g]then e=true break end end libError(not e,"type","3",f,"clear",1)c=c or 0 d=d or 255 ckId(c,"clear",3,0) ckId(d,"clear",4,1) local h,i=false,0 local function j()i,h=i+1,true end local k=(b)and 0 or ZERO if a=="memory" or a=="all" then for g=c,d do P51(g,k)j()end end if a=="class" or a=="all" then for g=#CID,1,-1 do if CID[g]>=c and CID[g]<=d then LBC[CID[g]]=nil CID[g]=nil j()end end return h end if a=="nonClass" then for g=c,d do if LBC[g]==nil then P51(g,k)j()end end return h end if a=="nonMemory" then local l=0 for g=#CID,1,-1 do l=CID[g]if l>=c and l<=d and(P51(l)<ZERO or P51(l)>MAX)then LBC[l]=nil CID[g]=nil j()end end return h,i end end TL4.swapClass=function(a,b)local function c(d,e,f)libError(T21(d)~="string",e,"3",nil,"swapClass",f)end c(a,"newName",1)c(b,"oldName",2)LBC[classToId(b,"swapClass",2)]=a end end
--local reference=TL4
