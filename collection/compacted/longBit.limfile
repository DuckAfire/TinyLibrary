-- NAME:    longBit
-- AUTHOR:  DuckAfire
-- VERSION: 3.5.0
-- LICENSE: Zlib License
--
-- Copyright (C) 2024 DuckAfire <duckafire.github.io/nest>
--
-- This software is provided 'as-is', without any express or implied
-- warranty. In no event will the authors be held liable for any damages
-- arising from the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictions:
--
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software. If you use this software
--    in a product, an acknowledgment in the product documentation would be
--    appreciated but is not required.
-- 2. Altered source versions must be plainly marked as such, and must not be
--    misrepresented as being the original software.
-- 3. This notice may not be removed or altered from any source distribution.

local DA4={}
do local T63,E3,P51,T19,SS14,T20,T21,SF3,TI1=trace,error,pmem,tonumber,string.sub,tostring,type,string.find,table.insert local function libError(a,b,c,d,e,f)if a~=nil then if not a then return end end local g={"Error","Function","Index"}local h={nil,e,"#"..f}local i="\n\n[longBit]"b=b and'"'..b..'" ' or"" local function j(k)h[1]=b..k end if c=="1" then j("was not specified")elseif c=="2" then j("was not defined")elseif c=="3" then j("is invalid")else j(c)end for l=1,3 do i=i.."\n"..g[l]..": "..h[l].."." if l==1 and d~=nil then i=i.."\nTry: " for m=1,#d-1 do i=i..d[l].." | " end i=i..d[#d] end end T63("\n>\n>\n>")E3(i.."\n")end local ZERO=2000000000 local MAX=2999999999 local LBC={} local CID={} local Origin={"getNum","getBool","setNum","setAll","update"}local GetBy=1 local SetBy=3 local AllBy=4 local function classToId(a,b,c)for d=1,#CID do if a==LBC[CID[d]]then return CID[d]end end libError(nil,nil,"Invalid class ("..a..")",nil,b,c)end local function ckSign(a,b,c)libError(a<0,nil,"It is not possible store negative values",nil,b,c)end local function ckId(a,b,c,d) a=(d~=2)and a or classToId(a,b,c)libError(a<0 or a>((d==1)and 255 or 9),"Index","3",nil,b,c)end local function ckDf(a,b,c) libError(P51(a)<ZERO or P51(a)>MAX,nil,"Memory not defined or invalid",nil,b,c)end local function ckGet(a,b,c,d) local e={a+1,a+1+(b or 1)-1}for f=1,2 do libError(e[f]<1 or e[f]>10-(f-1),((f==1)and"index" or"length"),"3",nil,c,d+2*(f-1))end return e[1],e[2] end DA4.getNum=function(a,b,c)ckId(a,Origin[GetBy],1,0)local d=classToId(b,"getNum",2)a,c=ckGet(a,c,Origin[GetBy],1)GetBy=1 return T19(SS14(T20(P51(d)),a,c))end DA4.getBool=function(a,b,c,d)GetBy=2 return DA4.getNum(a,b,d)==(c or 1)end DA4.getClass=function(a)ckId(a,"getClass",1,1)return LBC[a]end DA4.getAll=function(a,b)local c=classToId(a,"getAll",1)local d=SS14(T20(P51(c)),2)if b then return d end return T19(d)end DA4.setClass=function(a,b,c)c=c or 0 libError(T21(a)~="table","classes","1",nil,"setClass",1)local d=c+#a-1 libError(d>255,nil,"Index overflow (init + #classes - 1 > 255)",nil,"setClass",1)local e=1 local f=false local g=false for h=c,d do libError(a[e]=="" or SF3(a[e]," ")~=nil,nil,"Invalid class. Do not use void strings or strings with spaces",nil,"setClass",1)g=(LBC[h]==nil)if g or b then LBC[h]=a[e] end e=e+1 f=true if not g then for i=1,#CID do if CID[i]==h then f=false break end end end if f then TI1(CID,h)end end return#a==e end DA4.setNum=function(a,b,c,d)local e,f="",0 b,d=ckGet(b,d,Origin[SetBy],2) if T21(a)=="boolean" then g=(a)and 1 or 0 else g=T20(a)local h=(d+1)-b if h>1 then for i=1,h do g=(#g<h)and"0"..g or g end end f=T19(g)libError(f>10^h,nil,"Sub-memory OVERFLOW",nil,Origin[SetBy],1)end ckSign(f,Origin[SetBy],1)local j=classToId(c,Origin[SetBy],3)local function k(l,m)return SS14(T20(P51(j)),l,m)end local n=k(1,b-1)local o=k(d+1)SetBy=3 P51(j,T19(n..g..o))end DA4.setAll=function(a,b,c,d)if not c then ckSign(a,Origin[AllBy],1)end local e=classToId(b,Origin[AllBy],2)if c then a=P51(e)+a else a=T20(a)if#a<9 then for f=1,9-#a do a="0"..a end end a=T19("2"..a)end local g=(a<ZERO)and-1 or(a>MAX)and 1 or 0 if h then if g<0 then P51(e,ZERO) elseif g>0 then P51(e,MAX) else P51(e,a) end else libError(g<0,nil,"[ UNDERFLOW ]",nil,"setAll",1)libError(g>0,nil,"[ OVERFLOW ]",nil,"setAll",1)P51(e,a)end AllBy=4 return g end DA4.boot=function(a,b,c,d,e)c=c or 0 e=(T19(e)~=nil)and e or 0 local f,g,h=0,"",0 local i=c+#a-1 ckId(c,"boot",3,1)ckId(e,"boot",5,0) libError(#a>256,nil,"The table specified is bigger that 256",nil,"boot",1)libError(i>255,nil,"Index overflow (init + #memID - 1 > 255)",nil,"boot",1)for j=c,i do f=f+1 if P51(j)<=ZERO or b then g=a[f]h=T19(g)ckSign(h,"boot",1)libError(T21(g)~="string",nil,g.." is not a string",nil,"boot",1)libError(T19(h)==nil,nil,g.." cannot be converted to number",nil,"boot",1)libError(T19(h)>MAX,nil,g.." is too large (max: "..MAX..")",nil,"boot",1)while#g<9 do g=(d)and e..g or g..e end g=T19("2"..g)P51(j,g)end end return(#a==f)end DA4.update=function(...)local a,b={...},0 local c=a[2]ckDf(classToId(c,"update",2),"update",2)if not a[1]then local d=a[3]local e=a[4] libError(#d~=#e,nil,"The quantity of values and indexes must be equal",nil,"update","3-4")SetBy=5 local f,g="",0 for h=1,#e do f="values["..h.."] is not a " libError(T21(d[h])~="string",nil,f.."string",nil,"update",1)g=T19(d[h])libError(g==nil,nil,f.."number",nil,"update",1)DA4.setNum(g,e[h],c,#T20(d[h]))b=b+1 end return b end local i=T19(a[3]or 0)local j=a[4]or 1 local k,l=nil,(T21(c)=="string") if l then k=(DA4.getAll(c)~=j)else ckId(c,"update",2,2)k=(P51(c)~=j)end AllBy=5 if k then if l then DA4.setAll(i,c)else P51(c,i)end b=1 end return(b==1)end DA4.clear=function(a,b,c,d)local e=false local f={"all","memory","class","nonMemory","nonClass"}for g=1,#f do if a==f[g]then e=true break end end libError(not e,"type","3",f,"clear",1)c=c or 0 d=d or 255 ckId(c,"clear",3,0) ckId(d,"clear",4,1) local h=false local i=(b)and 0 or ZERO if a=="memory" or a=="all" then for g=c,d do P51(g,i)h=true end end if a=="class" or a=="all" then for g=#CID,1,-1 do if CID[g]>=c and CID[g]<=d then LBC[CID[g]]=nil CID[g]=nil h=true end end return h end if a=="nonClass" then for g=c,d do if LBC[g]==nil then P51(g,i)h=true end end return h end if a=="nonMemory" then local j=0 for g=#CID,1,-1 do j=CID[g]if j>=c and j<=d and(P51(j)<ZERO or P51(j)>MAX)then LBC[j]=nil CID[g]=nil h=true end end return h end end DA4.swapClass=function(a,b)local function c(d,e,f)libError(T21(d)~="string",e,"3",nil,"swapClass",f)end c(a,"newName",1)c(b,"oldName",2)LBC[classToId(b,"swapClass",2)]=a end end
--local reference=DA4
