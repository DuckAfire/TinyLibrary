-- NAME:    coli2DA
-- AUTHOR:  DuckAfire
-- VERSION: 3.1.2
-- LICENSE: Zlib License
--
-- Copyright (C) 2024 DuckAfire <duckafire.github.io/nest>
--
-- This software is provided 'as-is', without any express or implied
-- warranty. In no event will the authors be held liable for any damages
-- arising from the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it
-- freely, subject to the following restrictions:
--
-- 1. The origin of this software must not be misrepresented; you must not
--    claim that you wrote the original software. If you use this software
--    in a product, an acknowledgment in the product documentation would be
--    appreciated but is not required. 
-- 2. Altered source versions must be plainly marked as such, and must not be
--    misrepresented as being the original software.
-- 3. This notice may not be removed or altered from any source distribution.

local DA1={}
do local T63,E3,T21,MS22,F33,M42,MM12,MM14,M43,MA0=trace,error,type,math.sqrt,fget,mget,math.max,math.min,mouse,math.abs local function libError(a,b,c,d,e,f)if a~=nil then if not a then return end end local g={"Error","Function","Index"}local h={nil,e,"#"..f}local i="\n\n[coli2DA]"b=b and'"'..b..'"' or"" local function j(k)h[1]=b..k end if c=="1" then j("was not specified")elseif c=="2" then j("was not defined")elseif c=="3" then j("is invalid")else j(c)end for l=1,3 do i=i.."\n"..g[l]..": "..h[l].."." if l==1 and d~=nil then i=i.."\nTry: " for m=1,#d-1 do i=i.." | " end n=i..d[#d] end end T63("\n>\n>\n>")E3(i.."\n")end local RE="rect" local CI="circ" local SI="simp" DA1.newBody=function(a,b,c,d,e)if a==RE then return{x=b,y=c,width=d or 8,height=e or 8}end if a==CI then return{x=b,y=c,radius=d or 4}end if a==SI then return{x=b,y=c}end libError(nil,"type","3",{RE,CI,SI},"newBody",1)end local function ckbd(a,b)local c,d,e,f,g,h=1,{{},{}},0,nil,nil for i=1,#b do f,g,h=a[c],true,(b[i]==CI and 1 or b[i]==SI and 2 or 0)if T21(f)=="table" then d[i]=DA1.newBody(b[i],f.x or f[1],f.y or f[2],f.width or f.radius or f[3],f.height or f[4])e=e+1 else g=false e=e+4-h d[i]=DA1.newBody(b[i],a[c],a[c+1],a[c+2],a[c+3])end if g then c=2 else c=5-h end end return d[1],d[2],a,e+1 end DA1.distance=function(...)local a,b=ckbd({...},{SI,SI})return MS22((a.x-b.x)^2+(a.y-b.y)^2)end DA1.mapAlign=function(...)local a={...}local b,c,d,e,f=(T21(a[1])=="table" or(T21(a[1])~="table" and#a>=4))and RE or SI if T21(a[1])~="table" and#a<2 then libError(nil,nil,"Insuficient arguments for this call format",nil,"mapAlign","(quantity)")end c,g,a,d=ckbd(a,{b})e,f=c.x,c.y if a[d]then c.width=c.width or 8 c.height=c.height or 8 e=e+c.width//2 f=f+c.height//2 end return(e//8)*8,(f//8)*8 end DA1.tile=function(...)local a,b,c,d=ckbd({...},{RE})local e,f,g=a.width,a.height local h,i,j,k local g=c[d+1]or 0 local l=c[d+2]or 0 local m=c[d+3]or 0 if c[d]=="top" then h,i,j,k=0,-1,e-1,-1 elseif c[d]=="below" then h,i,j,k=0,f,e-1,f elseif c[d]=="left" then h,i,j,k=-1,0,-1,f-1 elseif c[d]=="right" then h,i,j,k=e,0,e,f-1 else libError(nil,"type","3",{"top","below","left","right"},"tile","(last)")end return F33(M42((a.x+h)//8+l,(a.y+i)//8+m),g)and F33(M42((a.x+j)//8+l,(a.y+k)//8+m),g) end DA1.tileCross=function(...)local a,b,c,d=ckbd({...},{RE})local e=T21(c[d+1])=="table" and c[d+1]or{}for f=1,4 do if not e[f]or T21(e[f])~="number" then e[f]=T21(c[d+1])=="number" and c[d+1]or 0 end end local g={}local h={[0]="top","below","left","right"}for f=0,3 do g[f]=DA1.tile(a,h[f],e[f+1],c[d+2],c[d+3])end return c[d]and{top=g[0],below=g[1],left=g[2],right=g[3]}or g end DA1.box360=function(a,b,c,d,e,f)local g=DA1.tileCross(c,false,d,e,f)local h=b and((b<0 and g[0])or(b>0 and g[1]))or false local i=a and((a<0 and g[2])or(a>0 and g[3]))or false return h or i end DA1.rectangle=function(...)local a={...}local b=T21(a[#a])=="boolean" and a[#a]or false local c=b and SI or RE local d,e=ckbd(a,{c,RE})if b then d.width,d.height=1,1 end return MM12(d.x,e.x)<MM14(d.x+d.width,e.x+e.width)and MM12(d.y,e.y)<MM14(d.y+d.height,e.y+e.height)end DA1.circle=function(...)local a={...}local b=T21(a[#a])=="boolean" and a[#a]or false local c=b and SI or CI local d,e=ckbd(a,{c,CI})local f=b and e.radius or d.radius+e.radius return(d.x-e.x)^2+(d.y-e.y)^2<=f^2 end DA1.shapesMix=function(...)local a,b=ckbd({...},{CI,RE})if DA1.rectangle({a.x,a.y},b,true)or DA1.circle({b.x+b.width//2,b.y+b.height//2},a,true)then return true end local c=a.radius*MS22(2)if DA1.rectangle(b,{1+a.x-c/2,1+a.y-c/2,c,c})then return true end local d,e=1,{DA1.distance({a.x,a.y},{b.x,b.y}), DA1.distance({a.x,a.y},{b.x+b.width,b.y}), DA1.distance({a.x,a.y},{b.x,b.y+b.height}), DA1.distance({a.x,a.y},{b.x+b.width,b.y+b.height}), }local f,g={e[1],e[2]},{{3,4},{1,3},{2,4}}for h=1,3 do if e[g[h][1]]<f[1]or e[g[h][2]]<f[2]then d=h+1 f[1]=e[g[h][1]]f[2]=e[g[h][2]]end end local i={{{b.x,b.y},{b.x+b.width,b.y}}, {{b.x,b.y+b.height},{b.x+b.width,b.y+b.height}}, {{b.x,b.y},{b.x,b.y+b.height}}, {{b.x+b.width,b.y},{b.x+b.width,b.y+b.height}}, }local j,k=i[d][1],i[d][2]while true do if DA1.circle({j[1],j[2]},a,true)then return true end if j[1]==k[1]and j[2]==k[2]then return false end j[1]=(j[1]+1<k[1])and j[1]+1 or k[1] j[2]=(j[2]+1<k[2])and j[2]+1 or k[2] end end DA1.touch=function(a,b,c,d,e)local f={}f.x,f.y=M43()e=e or{}f.width=e.width and MA0(e.width)or e[1]and MA0(e[1])or 1 f.height=e.height and MA0(e.height)or e[2]and MA0(e[2])or 1 return f.x+f.width-1>=a and f.x<=c and f.y+f.height-1>=b and f.y<=d end DA1.impactPixel=function(...)local a={...}local b=T21(a[#a])=="boolean" and#a-1 or#a if a[b]~=RE and a[b]~=CI then libError(nil,"type","3",{RE,CI},"impactPixel","(first)")end local c,d,e,f=ckbd(a,{a[b],a[b]})if e[b]==RE then if not e[b+1]and not DA1.rectangle(c,d)then return nil,nil end local g={x=c.x+c.width/2,y=c.y+c.height/2,radius=(c.width+c.height)/2}local h={x=d.x+d.width/2,y=d.y+d.height/2,radius=(d.width+d.height)/2}return DA1.impactPixel(g,h,CI,true)end if e[b]==CI then if not e[b+1]and not DA1.circle(c,d)then return nil,nil end local i=(c.x*d.radius)+(d.x*c.radius)local j=(c.y*d.radius)+(d.y*c.radius)local k=(c.radius+d.radius)return i/k,j/k end end end
--local reference=DA1
